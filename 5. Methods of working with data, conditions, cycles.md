# Методы поиска в строке

## Поиск по строке. Метод ```indexOf```

Метод ```indexOf``` ищет символ в строке и возвращает его индекс: 

```js
/* Метод indexOf */

'Яндекс.Практикум'.indexOf('Я'); // 0

/* Если таких символов в строке несколько,
метод вернёт индекс первого из них: */

'эспрессо'.indexOf('c'); // 1

/* Если символа в строке нет, indexOf вернёт -1: */

'эспрессо'.indexOf('к'); // -1 
```

```indexOf``` может найти и комбинацию символов. При этом вернётся индекс первого символа из последовательности:

```js
const blok = 'Ночь, улица, фонарь, аптека';
blok.indexOf('фонарь'); // 13 
```

```indexOf``` чувствителен к регистру:

```js
'Шалаш'.indexOf('Ш'); // 0
'Шалаш'.indexOf('ш'); // 4 
```

## Поиск по строке. Метод ```includes```

```js
'Гарри Поттер и узник Азкабана'.includes('Гарри Поттер'); // true
```

## Поиск в начале и конце строки. Методы ```startsWith``` и ```endsWith```

Методы ```startsWith``` и ```endsWith``` — более узконаправленные альтернативы ```indexOf```.

Метод ```startsWith``` сравнивает начало строки с переданной ему подстрокой. Он отвечает на вопрос: «Эта строка начинается с вот такого набора символов?» Если ответ «да», метод возвращает ```true```, иначе — ```false```:

```js
'Вендетта'.startsWith('В'); // true
'Родина'.startsWith('Картинка в букваре'); // false 
```

Метод ```endsWith``` делает всё то же самое, только с концом строки. Он отвечает на вопрос: «Эта строка заканчивается вот таким набором символов?»:

```js
const theRealEnd = 'Это ещё не конец';

theRealEnd.endsWith('конец'); // true 
```

---

# Методы преобразования строк

Управление регистром. Методы ```toLowerCase``` и ```toUpperCase```

Методы ```toLowerCase``` ```toUpperCase``` возвращают новую строку, все символы которой переведены в нижний и верхний регистр соответственно:

```js
'Включите Caps Lock'.toLowerCase(); // "включите caps lock"
'Выключите Caps Lock'.toUpperCase(); // "ВЫКЛЮЧИТЕ CAPS LOCK" 
```

Полезно вызывать один из методов, когда нужно сравнить две строки без учёта регистра:

```js
const firstStr = 'Такая проверка не пройдёт';
const secondStr = 'таКая пРовеРка не пройдёт';

console.log(firstStr === secondStr); // false
console.log(firstStr.toLowerCase() === secondStr.toLowerCase()); // true 
```

## Превращение строки в массив. Метод ```split```

Метод split принимает на вход один аргумент — разделитель. Он показывает, где заканчивается один элемент массива и начинается следующий. 

Разделителем может быть любой символ или набор символов:

```js
'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."] 
```

## Извлечение части строки. Метод ```slice```

Метод ```slice``` возвращает часть строки. На вход он принимает два аргумента — с какого индекса начинать отсчёт и на каком закончить:

```js
'Не прислоняться'.slice(6, 10); // "слон" 
```

Второй аргумент необязательный: если его не указать, ```slice()``` вернёт все символы от заданного в первом аргументе до конца строки:

```js
'Яндекс.Практикум'.slice(7); // "Практикум"
'Яндекс.Телефон'.slice(7); // "Телефон"
'Яндекс.Еда'.slice(7); // "Еда" 
```

---

# Методы для работы с числами

## Объект Math и его методы

У объекта ```Math``` много методов для работы с числами, основные:

```js
// округляет переданное число «вниз»
Math.floor(9.99); // 9

// округляет «вверх»
Math.ceil(9.01); // 10

// округляет до ближайшего целого
Math.round(9.51); // 10

// возвращает наибольшее из переданных чисел
Math.max(1, 2, 3, 4, 5); // 5

// возвращает наименьшее из переданных чисел
Math.min(1, 2, 3, 4, 5); // 1

// возвращает случайное число от 0 включительно до 1 не включительно
Math.random(); // 0.31764219954126016 
```

## Работа с дробной частью. Функция ```parseInt```

Функция ```parseInt``` приводит переданный аргумент к целому числу. Она читает аргумент слева направо, если встречает не цифру, останавливается и возвращает всё, что прочитала до этого:

```js
parseInt('38 попугаев'); // 38 
```

Если первый символ передаваемой строки не цифра, parseInt вернёт NaN:

```js
parseInt('Метро 2033'); // NaN 
```

Второй аргумент ```parseInt``` — система счисления, в которой число передаётся функции.

```parseInt``` определяет только то, в какой системе счисления передан первый аргумент, но на выходе мы всё равно получим десятичное число.

```js
parseInt('100', 10); // 100
parseInt('100', 2); // 4 (100 в двоичной системе) 
```

Чаще всего вам нужна десятичная система. Явно указывайте её, чтобы избежать неожиданных результатов.

## Функция ```parseFloat```

Функция ```parseFloat``` работает аналогично ```parseInt```, только выделяет не целое число, а число с плавающей точкой:

```js
parseFloat('36.6'); // 36.6
parseFloat('36.6 нормальная температура человека '); // 36.6 
```

## Проверка на принадлежность к целым числам. Метод ```Number.isInteger```

Метод ```Number.isInteger``` принимает число как аргумент и проверяет, целое оно или дробное:

```js
const eightAndAHalf = 8.5;

Number.isInteger(eightAndAHalf); // false
Number.isInteger(Math.floor(eightAndAHalf)); // true
```

---

# Неявное преобразование типов

При сложении числа со строкой движок превратит число в строку и только потом выполнит конкатенацию.

```js
console.log(100 + '500'); // "100500"
```

## Приведение к строке

Неявное преобразование к строчному типу происходит при сложении со строкой:

```js
1 + ''; // "1"
undefined + ''; // "undefined"
```

## Приведение к числу

Движок JavaScript приводит данные разных типов к числам, а затем их сравнивает:

```js
null >= 1; // false
'451' < 452; // true 
```

Оператор «унарный плюс» приводит нечисловые значения после «+» к численному типу. Так ```+'33'``` вернёт число 33, ```+'-77'``` вернет число -77.
Если операторы сложения и унарный плюс стоят рядом, они не помешают друг другу:

```js
console.log(67 + +'33'); // 100 
```

Приведение к числу выполнит и любой другой арифметический оператор. Кроме сложения со строкой — оно будет воспринято как конкатенация:

```js
console.log('3' - 1); // 2 — выполнилось приведение к числу
console.log('4' / 4); // 1 — тоже привелось к числу
console.log('2' * 2); // 4 — опять привелось
console.log('4' + 4); // 44 — а здесь выполнится конкатенация 
```

## Приведение к булевым значениям

В круглых скобках условия ```if``` любые данные всегда приводятся к логическому типу:

```js
const usernameElement = document.querySelector('.username');

if (usernameElement) {
  console.log('Привет, ' + usernameElement.textContent);
}
```

Если элемента с классом ```username``` на странице нет, в переменную ```usernameElement``` запишется ```null```. В круглых скобках условной конструкции ```null``` приводится к логическому типу и становится ```false```. Поэтому тело условия ```if``` выполнено не будет.

---

# Явное преобразование типов

## Приведение к строке

Глобальный объект ```String``` превращает переданный ему аргумент в строку:

```js
const numberToString = String(2); // "2"
const nanToString = String(NaN); // "NaN"
const undefinedToString = String(undefined); // "undefined"
const nullToString = String(null); // "null"
const booleanToString = String(true); // "true"
```

## Приведение к числу

Глобальный объект ```Number``` приводит переданный ему аргумент к числовому типу:  

```js
const stringToNumber = Number('2'); // 2
const nullToNumber = Number(null); // 0
```

Если передать произвольную строку или ```undefined```, вернётся ```NaN```.

```js
const anotherStringToNumber = Number('счастье не за горами'); // NaN
const undefinedToNumber = Number(undefined); // NaN 
```

## Приведение к булевым значениям

Метод ```Boolean``` преобразует переданный ему аргумент к «булю»:

```js
Boolean(2) // true
Boolean(0) // false
Boolean('') // false
Boolean('Непустая строка'); // true
```

Разберёмся подробнее, как разные значения приводятся к логическому типу. В **JavaScript** значения условно делятся на ```truthy``` *(англ. «правдивые»)* и ```falsy``` *(англ. «ложные»)*. Правдивые значения при приведении типа становятся Истиной, а ложные — Ложью. Правила такие:

* все непустые строки — ```truthy```,
* пустая строка ('') — ```falsy```,
* все ненулевые числа — ```truthy```,
* ноль — ```falsy```,
* NaN, null и undefined — ```falsy```,
* объекты, массивы и функции — ```truthy```.

```js
Boolean('Непустая строка'); // true
Boolean(''); // false
Boolean(1); // true
Boolean(0); // false
Boolean(NaN); // false
Boolean(null); //false
Boolean(undefined); // false
Boolean({}); // true
Boolean([]); //true
```

---

# Логические операторы

Логических операторов всего три:

* ``!`` — логическое **НЕ**,
* ``||`` — логическое **ИЛИ**,
* ``&&`` — логическое **И**.

# Оператор логическое НЕ (!)

Логическое **НЕ** делает из условия обратное: превращает ``true`` в ``false`` и наоборот. Для этого перед условием ставят восклицательный знак ``!``:

```js
!false; // true
```

Было условие «если три больше двух» — станет «если три НЕ больше двух»:

```js
!(3 > 2) === 3 <= 2; // true.

/* Потому что это превращается в проверку false === false */ 
```

Напишем функцию проверки пароля:

```js
let password = 'JavaScript';

function checkPassword(pass) {
    if (!(pass === password)) {
        console.log('Неверный пароль');
        return;
    }

    console.log('Пароль правильный');
}

checkPassword('java script'); // 'Неверный пароль'
checkPassword('JavaScript'); // 'Пароль правильный'
```

Если поставить ``!`` перед небулевым значением, движок JS сначала приведёт тип к булю, а затем изменит значение на противоположное:

```js
!'Непустая строка' // false 
```

Двойное отрицание сработает как перевод значения в логический тип:

```js
!!true; // true
!!'непустая строка'; // true
!!''; // false
!!1; // true
!!0; // false 
```

Оператором **НЕ** можно создавать анти-условия и приводить данные к булю. 

# Оператор логическое **ИЛИ (||)**

Логическое **ИЛИ** служит для связи таких условий, из которых должно быть выполнено хотя бы одно. Для этого между простыми условиями ставят два прямых слеша ``||``:

```js
true || false || false; // true

/* Оператору ИЛИ достаточно, чтобы хотя бы
одно простое условие было истинным */ 
```

Оператор **ИЛИ** идёт по простым условиям слева направо и проверяет каждое. Когда он встречает правдивое значение, то возвращает его как результат всего условия. Посмотрим на примере:

```js
let condition =  0 || NaN || 'строка' || false;

/* Значение переменной condition: 'строка'. */ 
```

В переменную ``condition`` записывается результат — значение первого истинного условия.

## Значение по умолчанию

Часто оператором ИЛИ присваивают переменной значение по умолчанию:

```js
function howDoYouDo(answer) {
    const result = answer || 'да ничего';
    return result;
}

howDoYouDo('всё прекрасно'); // "всё прекрасно"
howDoYouDo(); // "да ничего" 
```

Пока вы не передаёте аргумент функции ``howDoYouDo``, её вызов возвращает установленное по умолчанию значение **'да ничего'**. Это происходит из-за того, что оператор ``ИЛИ`` из пустоты и чего-нибудь определённого выбирает определённое.

# Оператор логическое **И (&&)**

Логическим **И** объединяют условия, которые должны выполняться одновременно. Для этого между условиями ставят двойной амперсанд ``&&``:

```js
(distance <= 100000) && (ownersNumber === 1) 
```

Если поставить ``&&`` между правдивыми условиями, оператор вернёт последнее из них:

```js
2 * 2 === 4 && 5 < 6 && 'Каждый может стать' // 'Каждый может стать' 
```

Если среди условий есть ложные, ``&&`` вернёт из них первое ложное:

```js
2 * 2 === 4 && undefined && 'Каждый может стать' // undefined 
```

## Приоритетность операторов

Cначала выполняется логическое **НЕ**, потом **И**, а затем — **ИЛИ**:

```js
const optimism = !'Жить' && !'Быть' || 'Жить и быть'; 

console.log(optimism); // "Жить и быть"

/* сначала выполняется !, потом &&, затем || */
```

Сначала ``!'Жить'`` → ``false``, потом ``!'Быть'`` → ``false``, затем ``false && false`` → ``false`` и наконец ``false || 'Жить и быть'`` → ``'Жить и быть'``.

Операции в скобках выполняются первыми:

```js
const pessimism = !'Жить' && (!'Быть' || 'Жить и быть'); 

console.log(pessimism); // false 
```

## Пример с автомобилем

В исходном примере получился такой код:

```js
function checkTheCar (distance, ownersNumber, crushed, cost) {
    if (distance <= 100000) { // проверяем пробег
        if (ownersNumber === 1) { // 1 владелец по ПТС?
            if (crushed === false) { // не битая?
                if (cost <= 1000000) { // стоит меньше миллиона?
                    return true; 
                } else return false;
            } else return false;
        }
        else if (ownersNumber === 2) { // владелец не 1? Тогда, может, 2?
            if (crushed === false) { // не битая?
                if (cost <= 1000000) { // стоит меньше миллиона?
                    return true;
                } else return false;
            } else return false
        } else return false;
    } else return false;
}

checkTheCar(50000, 2, false, 700000); // true. Надо же! Работает. 
```

С логическими операторами вы можете переписать этот кошмар.

Условия покупки машины:

* пробег не больше 100 тысяч км,
* один или два владельца по ПТС,
* не битая,
* не дороже миллиона.

Пишем код:

```js
function checkTheCar (distance, ownersNumber, crushed, price) {
    const condition = distance <= 100000 && (ownersNumber === 1 || ownersNumber === 2) && !crushed && price <= 1000000;
    return condition;
}

checkTheCar(50000, 2, false, 700000); // true — фух, работает
```

---

# Конструкция switch-case

Оператор switch применяют, когда в условии только один ответ правильный. Каждый вариант описывают между ключевым словом case и инструкцией break:

```js
switch (/* Переменная для проверки */) {
    case /* Первое возможное значение:
        Выполняемый код */
        break;
    case /* Второе возможное значение:
        Выполняемый код */
        break;
    ...
    case /* n-ое возможное значение:
        Выполняемый код */
        break
}
```

Каждый раз case завершается ``break``: так движок JS понимает, что из конструкции ``switch-case`` нужно выйти.
Если не поставить ``break``, сработает код не только «нужного» ``case``, но и всех под ним:

```js
const yourNumber = 'Л055';
let windowNumber;

switch (yourNumber) {
  case 'Л054':
    windowNumber = 1;
  case 'Л055':
    windowNumber = 2;
  case 'Л056':
    windowNumber = 3;
  case 'Л057':
    windowNumber = 4;
  case 'Л058':
    windowNumber = 5;
}

console.log(windowNumber); // 5
```

Поэтому для последнего ``case`` писать ``break`` не нужно.

Можно сознательно пропустить break, чтобы прописать логику сразу нескольких случаев:

```js
let catName;
const cartoon = 'Зима в Простоквашино';

switch (cartoon) {
    case 'Зима в Простоквашино':
    case 'Весна в Простоквашино':
    case 'Трое из Простоквашино':
        catName = 'Матроскин';
        break;
    case 'Лето кота Леопольда':
        catName = 'Леопольд';
}

console.log(catName); // "Матроскин"
```

Ещё есть необязательная инструкция default. Сюда записывают код, который должен сработать, если ни один case не подошёл:

```js
let catName;
const cartoon = 'Лето кота Леопольда';

switch (cartoon) {
    case 'Зима в Простоквашино':
        catName = 'Матроскин';
        break;
    default:
        catName = 'Леопольд';
}

console.log(catName); // "Леопольд" 
```

---

# Тернарный оператор

Конструкции ``if-else`` и ``switch-case`` слишком громоздкие для небольшого кода. Тут нужен тернарный оператор. Он состоит из условия и двух значений: первое вернётся, если результат проверки ``true``, второе — если ``false``.

Конструкция с тернарным оператором состоит из условия и двух значений:

```js
/* условие */ ? /* значение, если true */ : /* значение, если false */
```

Такая конструкция возвращает первое значение, если условие — ``true``, и второе, если ``false``.

Обычно тернарный оператор используют, когда в зависимости от условия нужно записать в переменную разные значения:

```js
const a = 5;
const b = a > 10 ? 5 : 0;

console.log(b); // 0, потому что a > 10 — false 
```

Главное отличие — **тернарный оператор** возвращает значение, а условная конструкция — нет.

Используйте **тернарный оператор**, когда результат зависит от какого-нибудь логического выражения:

```js
const value = 'любит';

console.log(value === 'любит' ? 'к сердцу прижмёт' : 'к чёрту пошлёт');

// "к сердцу прижмёт" 
```

---

# Циклы. Директивы **break** и **continue**

## Остановка цикла. Директива ``break``

Директива ``break`` останавливает цикл:

```js
for (let i = 2019; i < 2119; i++) {
    if (i % 4 === 0 && i % 100 !== 0) { // високосный год кратен 4, но не кратен 100
        console.log('Ближайший високосный год: ' + i);
        break;
    }
}

// 'Ближайший високосный год: 2020' 
```

Директива ``break`` нужна, когда дальнейшее выполнение цикла бессмысленно или может привести к неправильным результатам.

Если из примера убрать ``break``, в консоль будут выведены все високосные годы от 2020 до 2116 и каждый с пояснением, что это ближайший високосный год.

Обратите внимание на ``i++`` в примере. Такая запись называется инкремент и означает «прибавь к переменной i единицу». Выражение ``i--`` вычтет единицу из ``i``. Это декремент.

## Прерывание итерации цикла. Директива ``continue``

Директива ``continue`` не прерывает весь цикл, а только пропускает текущую итерацию.

Так мы можем настроить, какие итерации выполнять, а какие нет:

```js
for (let i = 2090; i < 2110; i++) {
  if (i % 4 === 0) {
    if (i % 100 === 0) continue; // пропуск года, кратного 100
    console.log('Високосный год: ' + i);
  }
}

// Високосный год: 2092
// Високосный год: 2096
// Високосный год: 2104
// Високосный год: 2108

/* Скрипт вывел все високосные годы от 2090 до 2110, но пропустил год 2100 */
```
