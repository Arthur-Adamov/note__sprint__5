# DOM: выбор элементов

Чтобы посмотреть на DOM, откройте в инструментах разработчика вкладку ”Elements“. То, что вы увидите, очень похоже на разметку веб-страницы. Но это не совсем так: на самом деле вы смотрите не на теги, а на элементы DOM-дерева. Отсюда и название вкладки.

Любое ветвление дерева называют узлом. Он возникает там, где есть:
* открывающий тег;
* текст;
* HTML-комментарий.

Обратите внимание: **узел** — более ёмкое понятие, чем элемент. **Элемент** — то, что мы называем тегом: он может быть парным или одиночным. 

* ```<img>``` или ```<a></a>``` — элемент.
* Текст <a>находящийся внутри ссылки ```</a>``` — текстовый узел.
* Набор тегов ```<a></a>``` — узел.

Узел — это все сущности, которые мы можем увидеть на странице, в том числе и элементы. Текст, комментарии, теги — это узлы.


## Поиск элементов в DOM-дереве

Научимся искать элементы в DOM-дереве. Будем работать с методами: ```querySelector``` и ```querySelectorAll```.
Оба метода принимают на вход строку — селектор нужного элемента. Удобно, что аргументы нужно писать так же, как в CSS:

```js
<!-- index.html -->

<main id="container">
  <div class="content">
    <div class="content__item"></div>
    <div class="content__item"></div>
    <div class="content__item"></div>
  </div>
</main> 
```

```js
/* script.js */

// Для выбора элемента по идентификатору
let container = document.querySelector('#container');

// По имени класса
let content = container.querySelector('.content');

/* Обратите внимание: мы ищем элементы не по всему
DOM-дереву, а внутри уже найденного элемента */
let contentItems = content.querySelectorAll('.content__item'); 
```

Если передать класс как аргумент методу ```querySelector```, метод вернёт первый на странице элемент с этим классом (тот, что выше в вёрстке). 

```querySelectorAll``` вернёт все подходящие под селектор элементы.

Главное преимущество этих методов — возможность искать элементы по сложным составным селекторам:

```js
<!-- index.html -->

<section class="bag">
  <div class="item">
    Очешник
        <p>Очки</p>
    </div>
  <p class="item">Расчёска</p>
  <p class="item">Зеркальце</p>
  <div class="item bag">Косметичка
    <p class="item">Помада</p>
    <p class="item">Тушь</p>
  </div>
  <p class="item wallet">Бумажник</div>
</section> 
```

```js
/* script.js */

let cosmeticBagContent = document.querySelectorAll('section.bag div.bag .item');
console.log(cosmeticBagContent); // Будут выбраны помада и тушь 
```

Методы ```querySelector``` и ```querySelectorAll``` могут искать элементы не только у объектов, но у других элеменентов (например в переменных).

---

# Атрибуты и их методы

У тегов есть атрибуты: ```href``` у ```<a>```, ```src``` у ```<img>```, ```class``` у любого тега. Управляя атрибутами, вы управляете самими элементами: отмечаете, какой элемент показать и какой скрыть, определяете размеры блоков, их расположение.

Управлять атрибутами можно:

* вызовом специальных методов;
* заменой атрибута через свойство DOM-элемента;
* обращением к специальным свойствам.

С атрибутом HTML-элемента можно выполнить одно из четырёх действий:

* получить значение;
* изменить значение;
* проверить наличие;
* удалить атрибут.

## Получаем значение атрибута: метод ```getAttribute```

Метод ```getAttribute``` принимает на вход имя атрибута и возвращает его значение:

```js
/* получаем первый элемент в DOM, описанный тегом <img>,
т. е. первое изображение на странице */

let imageOnPage = document.querySelector('img');

imageOnPage.getAttribute('src'); // вернётся ссылка, записанная в атрибуте src первого изображения, которое вернул метод querySelector 
```

Если у элемента нет атрибута, который мы запросили, или подобного атрибута не существует вовсе, вернётся специальное значение **null**. Если атрибут задан, но не подразумевает значения, например, ```disabled```, мы получим пустую строку:

```js
<button id="big-red-button" onclick="alert('Бум!');" disabled>
  Кнопка самоуничтожения
</button> 
```

```js
// получаем по идентификатору кнопку и сохраняем в переменной bigAndRed
let bigAndRed = document.querySelector('#big-red-button');

// исследуем элемент-кнопку методом getAttribute
bigAndRed.getAttribute('lang'); // null
bigAndRed.getAttribute('несуществующий атрибут'); // null
bigAndRed.getAttribute('disabled'); // '' 
```

## Проверяем, есть ли у тега атрибут: метод ```hasAttribute```

Убедиться в наличии атрибута удобно методом ```hasAttribute```, который возвращает ```true```, если атрибут задан, и ```false```, если нет.

```js
bigAndRed.hasAttribute('onclick'); // true
bigAndRed.hasAttribute('несуществующий атрибут'); // false
bigAndRed.hasAttribute('disabled'); // true 
```

## Задаём значение атрибута: метод ```setAttribute```

Метод ```setAttribute``` принимает на вход два аргумента: имя атрибута, значение которого мы хотим задать, и само значение:

```js
bigAndRed.setAttribute('lang', 'ru');
сonsole.log(bigAndRed.hasAttribute('lang')); //true 
```

Оба аргумента — **строки**. Если передать значение другого типа, оно всё равно будет приведено к строке.

```js
disabledCheckbox.setAttribute('disabled', true); // Делаем чекбокс неактивным. 
```

## Атрибуты без значения

Чтобы сделать чекбокс неактивным, нужно передать методу ```setAttribute``` два аргумента: ```disabled``` и любой другой. Согласно спецификации, у ```setAttribute``` есть два обязательных параметра, но в то же время ```disabled``` не предполагает никакого значения. Получается, чтобы метод сработал, второй аргумент необходим, но его значение неважно:

```js
disabledCheckbox.setAttribute('disabled', true);
disabledCheckbox.setAttribute('disabled', 'Значение этого аргумента может быть любым');
disabledCheckbox.setAttribute('disabled', 'Мы передаём его, только чтобы метод отработал');
disabledCheckbox.setAttribute('disabled', false); // и даже этот вызов сработает 
```

## Удаляем атрибут: метод ```removeAttribute```

Метод removeAttribute удаляет атрибут у элемента:

```js
bigAndRed.hasAttribute('disabled'); // true
bigAndRed.removeAttribute('disabled'); // удаляем атрибут
bigAndRed.hasAttribute('disabled'); // false 
```

---

# Работа с атрибутами через встроенные свойства

Когда мы хотим работать с элементом на странице, сначала нужно сделать из него объект: ведь JS умеет работать только с объектами. При этом атрибуты тега становятся свойствами объекта:

```js
<!-- Задаём тегу a атрибут href -->
<a href="https://ya.ru">Поиск</a> 
```

```js
// Выбираем элемент a
let a = document.querySelector('a');

a.href; // https://ya.ru — у элемента a появилось свойство href 
```

В этом и заключается управление атрибутами через свойство объекта. Их можно не только получать, но и перезаписывать:

```js
a.href = 'https://praktikum.yandex.ru/' 
```

---

# Манипуляции с классами CSS

## Получение имени класса. Свойство ```className```

У каждого элемента **DOM** есть свойство ```className```. С его помощью можно прочитать или записать значение атрибута ```class```:

```js
<div class="princess">Елизавета</div> 
```

```js
// выбираем элемент c классом 'princess'
let rank = document.querySelector('.princess');
console.log(rank.className); // princess

rank.className = 'queen'; // принцесса стала королевой, перезаписываем класс на 'queen'
console.log(rank.className); // queen 
```

Если у элемента несколько классов, в свойстве ```className``` они будут разделены пробелами:

```js
<div class="her majesty queen">Елизавета</div> 
```

```js
// выбираем элемент c классом 'queen'
let rank = document.querySelector('.queen');

console.log(rank.className); // her majesty queen 
```

## Получение списка классов. Свойство ```classList```

Для управления атрибутом ```class``` удобнее пользоваться свойством ```classList```. Оно содержит список всех классов элемента и обладает собственными методами, чтобы управлять этими классами.

```js
<!-- В именах классов записаны марки машин Её Величества -->
<div class="bentley rolls-royce">Королевский гараж</div> 
```

```js
/* получаем список машин королевы в переменной,
обратившись к соответствующему элементу с селектором .bentley */

let garage = document.querySelector('.bentley');
console.log(`Гараж Её Величества: ${garage.classList}`); // Гараж Её Величества: bentley rolls-royce 
```

## Проверка наличия класса. Метод ```contains```

Метод ```contains``` проверяет, есть ли у элемента класс, переданный как аргумент:

```js
let garage = document.querySelector('.bentley');

garage.classList.contains('bentley'); // true — bentley есть
garage.classList.contains('jaguar'); // false — а jaguar нет 
```

## Присвоение класса элементу. Метод ```add```

Метод ```add``` добавляет элементу класс:

```js
// в королевский гараж поступил Ягуар
garage.classList.add('jaguar');

console.log(`Гараж Её Величества: ${garage.classList}`); // bentley rolls-royce jaguar 
```

## Удаление класса. Метод ```remove```

Метод ```remove``` удаляет у элемента класс, переданный как аргумент:

```js
garage.classList.remove('jaguar'); // Ягуар надоел

console.log(`Гараж Её Величества: ${garage.classList}`); // bentley rolls-royce 
```

## Переключение класса. Метод ```toggle```

Метод ```toggle``` работает как ```add```, если у элемента класс отсутствует, и как ```remove``` — если присутствует. То есть метод переключает класс у элемента:

```js
<div class="bentley rolls-royce jaguar">Королевский гараж</div> 
```

```js
// А если Ягуар есть, нужно от него избавиться  
garage.classList.toggle('jaguar');

console.log(`Гараж Её Величества: ${garage.classList}`); // bentley rolls-royce 
```

---

# Управление содержимым: свойства ```.innerHTML``` и ```.textContent```

Чтобы получить содержимое тега, используют свойства ```innerHTML``` и ```textContent```.

## Содержимое элемента. Свойство innerHTML

Свойство ```innerHTML``` содержит в себе строку со всем наполнением элемента (в том числе и разметкой):

```js
document.body.innerHTML; // Если в документе нет разметки, вернёт пустую строку. 
```

```innerHTML``` позволяет не только получить значение свойства, но и перезаписать его:

```js
document.body.innerHTML = '<div>Добавим разметку</div>'; // Теперь на странице есть только один div. Если бы перед этим в документе была какая-либо разметка, она была бы заменена этим одним div. 
```

## Текстовое содержимое. Свойство ```textContent```
```textContent``` позволяет получить или перезаписать текстовое содержимое элемента. Обратите внимание: вёрстка при этом не затрагивается.
 
```js
<p id="paragraph">Это текст внутри элемента.</p> 
```

```js
let paragraph = document.getElementById('paragraph');
console.log(paragraph.textContent); // "Это текст внутри элемента."
paragraph.textContent = 'А это новый текст.'; // можно перезаписать содержимое 
```

## Другой способ заменить текстовое содержимое. Свойство ```innerText```

Есть ещё одно свойство — ```innerText```, которое тоже предназначено для получения текстового содержимого. Оно отличается от textContent тем, что ```innerText``` возвращает только видимое текстовое содержимое. То есть ```innerText``` проигнорирует всё, что скрыто свойством ```display: none```, а ```textContent``` — нет:

```js
<p id="paragraph">
  Это текст внутри элемента.
  <span style="display: none;">Невидимый текст.</span>
</p>
```

```js
let paragraph = document.getElementById('paragraph');

console.log(paragraph.innerText); // Это текст внутри элемента.
console.log(paragraph.textContent);
/* Это текст внутри элемента.
Невидимый текст. */
```

Когда нужно прочитать или изменить текстовое содержимое, лучше обращаться к ```textContent```. На это есть две причины:

* ```textContent``` работает гораздо быстрее, потому что игнорирует правила видимости.
* Свойство ```innerText``` не стандартизировано. Его придумали в Microsoft ещё до появления ```textContent```. Оно стало популярным, и другие производители начали внедрять его в свои браузеры. Но в стандарте ```innerText``` по-прежнему нет, а значит, его поведение в разных браузерах может отличаться. А ещё нет гарантий, что оно не изменится в будущем.

Запомнить стоит два свойства: ```innerHTML``` и ```textContent```. **Первое** пригодится для управления разметкой, **второе** — текстовым содержимым.