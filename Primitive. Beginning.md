# Примитивные типы данных. Оператор **typeof**

В JavaScript данные делятся на:

* объекты, имеющие свойства пары: «ключ + значение»;
* примитивы (элементарные типы), у которых есть только значение.

Примитивных типов семь:
* **строки** (тип “string”);
* **числа** (тип “number”);
* **большие числа** (тип “bigint”);
* **булевы значения** true и false (тип “boolean”);
* **undefined** (тип “undefined”);
* **null** (тип “null”);
* **символы** (тип “symbol”).

## Определение типа данных. Оператор **typeof**

Тип данных определяют оператором ```typeof```. Оператор ```typeof``` возвращает строку:

```js
typeof 10; // "number"
typeof 'Hello World!'; // "string"
typeof true; // "boolean"
typeof undefined; // "undefined" 
```

Работа ```typeof``` выглядит простой и понятной, но есть 3 случая, когда результат работы ```typeof``` неочевиден:

```js
typeof NaN; // "number". Да, "Not a Number" имеет тип данных "number".
typeof null; // "object". Это даже было признано официальным багом JavaScript. Его решили не исправлять, чтобы не сломать уже написанный код.
typeof function () {} // "function". Хоть такого типа и нет. 
```

Помните об этих случаях, если решите использовать ```typeof``` в своём коде. Иначе можно спутать объект с ```null```.

## Символы

Фактически их можно воспринимать как гарантированно уникальное значение, предоставляемое JavaScript. Для его создания нужно явно обратиться к типу по имени Symbol и в качестве аргумента передать подпись:

```js
let id = Symbol('id');
console.log(id); //Выведет Symbol(id) 
```

В этом примере мы подписали символ строковым значением **id**, что позволит нам отличать символы между собой при выводе в консоль или в отладчике. Подпись не обязательно должна быть строкой — это может быть любой тип данных. Причём, если мы сделаем ещё одну переменную и проинициализируем её как символ с такой же подписью, то получим новое значение, не равное предыдущему.

```js
let A = Symbol('A');
let B = Symbol('A');
console.log(A === B); //Выведет false 
```

В каких ситуациях нам будет удобно использовать символы? Во-первых, при создании констант, если они используются только в памяти во время исполнения JS.

```js
const STATE_UP = Symbol('UP');
const STATE_DOWN = Symbol('Down');
let status = STATE_UP;
switch (status) {    
    case STATE_UP:        //мы точно уверены, что статус именно такой        
        break;    
    case STATE_DOWN:        
        break;    
    default:        
        break;
} 
```

Либо мы можем использовать символы как ключи объектов для создания неитерируемых свойств:

```js
const ID = Symbol('ID');
const Role = Symbol('Role');
let user = {    name: 'John',    age: 25,    [ID]: 67,    [Role]: 'guest'};
for (let key in user) console.log(key);
//name
//age
console.log(user[ID]); //67 
```

Так мы можем добавить к объекту поля, скрытые от всех, у кого нет нашего «ключа» — переменной, содержащей исходный символ. Это позволит нам прикрепить к объекту какие-то служебные или защищённые данные.

---

# Два одиноких типа данных. **undefined** и **null**

## Значение не определено. **undefined**

Если в объявленной переменной ничего не хранится, JavaScript записывает в неё специальное значение ```undefined```. **undefined** — отдельный тип данных, который состоит всего из одного значения:

```js
/* Объявим переменную meaningOfLife
Значение ей пока не присвоено. */
let meaningOfLife;

// Тип значения переменной meaningOfLife пока что undefined.
typeof meaningOfLife; // "undefined" 
```

Если явно не указать в функции, что она возвращает, она вернёт ```undefined```.

Если переменная равна ```undefined```, значит, она объявлена, но в неё ничего не записано. То же значение возвращается при обращении к несуществующему свойству объекта:

```js
const myMind = {};

console.log(myMind.location) // undefined 
```

## Значения нет. **null**
**null** — это особое значение и отдельный тип данных. ```null``` сигнализирует, что значения нет.

Некоторые встроенные функции и методы возвращают ```null```, когда не могут вернуть что-то осмысленное. Знакомый вам ```querySelector``` возвращает ```null```, если не нашёл на странице элемент с искомым селектором:

```js
const element = document.querySelector('.non-existing-class');

if (element === null) {
  console.log('Элемента с таким классом нет на странице');
} 
```

---

# Строки

## Определение длины строки. Свойство **length**

У любого текста есть длина. Это значение свойства length, равное количеству символов в строке:

```js
console.log('АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'.length);  // 33
const greekAlphabet = 'αβγδεζηθικλμνξοπρστυφχψω';
console.log(greekAlphabet.length); // 24 
```

## Получение символа строки по индексу

Квадратные скобки — простой способ получить символ из строки по его индексу, то есть обратиться к нему как к элементу массива. Индекс первого символа в строке — ноль:

```js
console.log('эспрессо'[0]); // "э"

/* можно таким же способом запросить символ
обращением к переменной, в которой сохранена строка: */

const wrongWord = 'экспрессо';
console.log(wrongWord[1]); // "к"

/* Если запросить слишком большой индекс, получим undefined */
console.log('экспрессо'[20]); // undefined 
```

---

# Числа и специальные числовые значения

## Бесконечность. Метод ```Number.isFinite```

В JavaScript две бесконечности — **Infinity** и **-Infinity**. Это самое большое и самое малое числовые значения в языке:

```js
// деление на 0 — это бесконечность
25 / 0; // Infinity

// если разделить на 0 отрицательное число,
// получим минус бесконечность
-25 / 0; // -Infinity

// бесконечность минус что угодно — бесконечность
Infinity - 1000000000; // Infinity 
```

Метод ```Number.isFinite``` проверяет код на «бесконечность». Если ```Number.isFinite``` передать на вход любую из бесконечностей, он вернёт ```false```, конечное число — ```true```:

```js
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
Number.isFinite(1703); // true 
```

## NaN — Not a Number. Метод ```Number.isNaN```


Если JavaScript не знает, как посчитать результат арифметического выражения, он сообщает об этом специальным значением — **NaN**.
Например, **NaN** возвращается, если умножить число на строку:

```js
console.log(10 * 'десять'); // NaN 
```

## Системы исчисления

Чтобы в JavaScript задать число в системе исчисления, отличной от десятичной, используются префиксы **```0x```** для шестнадцатеричной и **```0b```** для двоичной:

```js
let hex = 0xFF; //255
let binary = 0b011110; //30 
```

После объявления эти числа можно использовать в вычислениях наряду с десятичными, но при выводе они будут автоматически сконвертированы в десятичную систему. Если нужно сохранить представление, то переменную можно принудительно привести к строке в нужной системе:

```js
let num = 1234; //это десятичное число
num.toString(16); //4d2 это уже шестнадцатеричное число
num.toString(2); //10011010010 а вот так двоичное 
```

Для обратного преобразования из строки в число нам поможет функция parseInt и её второй аргумент:

```js
parseInt('4d2', 16); //из шестнадцатеричной
parseInt('10011010010', 2); //из двоичной 
```

## Большие числа ```BigInt```

Это специальный числовой тип данных, который представляет числа в формате длинной арифметики. В JavaScript, чтобы получить число в таком формате, вам потребуется объявить его в специальном формате 1234567890n или через прямое преобразование типов BigInt(1234567890).

Большие числа поддерживают все арифметические операции между собой, но не конвертируются автоматически при выполнении операций со смешанными данными. Вам потребуется конвертировать типы явно в нужный формат.