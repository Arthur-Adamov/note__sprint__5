# Функции. Повторение

## Объявление и вызов функций

```js
// объявляем функцию sayHello
function sayHello() {
  console.log('Привет');
}

// вызываем её
sayHello(); // "Привет"
```

## Аргументы и возвращаемое значение

Функции могут принимать аргументы и возвращать значения:

```js
function multiply(a, b) { // функция принимает множители
  return a * b; // и возвращает произведение
}

multiply(2, 3); // 6
```

---

# Область видимости функции

Если переменная определена внутри функции, снаружи обратиться к ней не получится.

```js
function giveMeSomeInternet() {
  const a = 'INTERNET'; // создали переменную a внутри функции giveMeSomeInternet
}

console.log(a); // ReferenceError: a is not defined
```

## Правила поиска переменной

**Первое правило**. Если идентификатор создан внутри функции, обратиться к нему снаружи нельзя.

**Второе правило**. Если обратиться к идентификатору из функции, движок сначала поищет идентификатор в теле этой функции. Если не найдёт — начнёт искать снаружи.

```js
let batteriesNumber = 12;
let batteriesInTetris = 4;

function findBatteries() {
  const batteriesNumber = 8;

  /* внутри функции есть идентификатор batteriesNumber
  именно это значение оказывается в консоли */
  console.log(batteriesNumber); // 8

  /* внутри функции такого идентификатора нет,
  поэтому движок взял значение из кода снаружи */
  console.log(batteriesInTetris); // 4
}
```

## Глобальная область видимости

Область видимости вне любых функций называется глобальной. Идентификаторы, определённые в ней, видны везде.

Переменную называют **глобальной**, если она объявлена в глобальной области видимости, и **локальной** — если внутри функции.

---

# Затенение идентификаторов

Если в теле функции обратиться к идентификатору, движок JavaScript сначала ищет его в теле этой функции, и уже потом снаружи. Поэтому если и снаружи, и внутри есть одинаковые идентификаторы, движок остановится на внутреннем, а внешний — проигнорирует.

Говорят, «внутренняя переменная затеняет внешнюю». С функциями то же самое:

```js
function callMeFromTheInside() {
    console.log('Hello');
}

function callMe() {
  function callMeFromTheInside() {
      console.log('world');
  }
  callMeFromTheInside();
}

callMe(); // "world"
```

Когда движок увидел идентификатор ``callMeFromTheInside`` внутри функции ``callMe``, он остановил свои поиски. Внутренняя функция затенила внешнюю.

---

# Способы создания функции

## Объявление функции

Всё это время мы создавали функции так: писали слово function, потом имя функции, в круглых скобках параметры, и затем в фигурных — тело функции.

```js
function multiply(a, b) {
  return a * b;
}
```

Этот код создаст идентификатор multiply и присвоит ему код функции. После этого функцию можно вызвать по имени:

```js
multiply(2, 3); // 6
```

## Функциональные выражения

В переменную можно записать и функцию — так же, как число или строку:

```js
// запишем функцию в переменную multiply
const multiply = function (a, b) {
  return a * b;
};

// её можно вызвать по имени
multiply(2, 3); // 6
```

## Возможность вызова до объявления

Объявленную функцию **можно** вызвать до объявления, функциональное выражение — **нельзя**.

Такой код сработает:

```js
// сначала вызвали функцию
double(2); // 4

// а потом объявили
function double(num) {
  return num * 2;
}
```

Так работает движок **JavaScript**. Сначала он просматривает код и, если находит объявление функции, создаёт её. Только после этого код исполняется.

С функциональным выражением такое не пройдёт:

```js
double(2); // ошибка

const double = function (num) {
  return num * 2;
};
```

---

# Функции — это значения

Функцию даже можно вернуть из другой функции:

```js
function createFunction() {
  function simpleFunction() {
    console.log('Меня вернули, а затем вызвали!');
  }

  /* мы не вызываем функцию, а возвращаем её */
  return simpleFunction;
}

// в newFunction запишется ссылка на simpleFunction
const newFunction = createFunction();

newFunction(); // "Меня вернули, а затем вызвали!"
```

Благодаря возможности делать с функцией то же, что и с любым другим значением, её называют **объектом первого класса**.

---

# Стрелочные функции

Стрелочными могут быть только функциональные выражения. Сравним их запись:

```js
// функциональное выражение
const consoleCat = function (cat) {
  console.log(cat);
};

// стрелочная функция
const consoleWombat = (wombat) => {
  console.log(wombat);
};
```

## Короткий ``return``

Если директива ``return`` — единственное действие в теле стрелочной функции, можно опустить и директиву ``return``, и фигурные скобки:

```js
/* эти функции идентичны */

const singleAnecdote = (anecdote) => {
  return `я знаю только один анекдот: ${anecdote}`;
};

const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`;
```

Если возвращаемое значение — **объект**, его нужно заключить в круглые скобки. Иначе то, что в фигурных скобках, движок воспримет как **тело** функции:

```js
// вот так правильно
const colorHex = () => ({ white: '#FFF' });

// а вот так не сработает
const colorHexWhite = () => { white: '#FFF' };
```

## Короткая запись параметров

Если у стрелочной функции один параметр, можно не заключать его в скобки: 

```js
// несколько параметров стрелочной функции указывают в скобках 
const boatDeparture = (eater, food) => {
  console.log(`через речку в лодке поплывут ${eater} и ${food}`);    
};

boatDeparture('козёл', 'капуста');

// через речку в лодке поплывут козёл и капуста

// если параметр один, скобки необязательны 
const boatArrival = survivor => {
  console.log(`до другого берега доберётся только ${survivor}`);
};

boatArrival('козёл');

// до другого берега доберётся только козёл
```

## Стрелочные функции как **коллбэки**

Стрелочные функции часто передают как коллбэки:

```js
const array = [1, 2, 3, 4];

array.forEach(() => {
  console.log('Кнопка нажата!');
});
```

Это особенно удобно, когда единственное, что делает коллбэк, — возвращает значение. Можно использовать короткий ``return``:

```js
const array = [1, 2, 3, 4];

const newArray = array.map(elem => elem * 2);
```

---

# Аргументы по умолчанию

В **ES6** появилась возможность задать значение аргумента по умолчанию:

```js
function generateName(firstName, lastName, middleName = '') {
    return `${firstName} ${middleName} ${lastName}`;
}

generateName('Маша', 'Петрова'); // Маша  Петрова
generateName('Мария', 'Петрова', 'Ивановна'); // Мария Ивановна Петрова
```

Параметр по умолчанию может принимать любое значение: число, строку, объект, функцию. Это значение будет присвоено параметру, если аргумент не передан или равен ``undefined``.

```js
function generateName(firstName, lastName, middleName = '<без отчества>') {
    return `${firstName} ${middleName} ${lastName}`;
}

generateName('Маша', 'Петрова'); // Маша <без отчества> Петрова
generateName('Маша', 'Петрова', undefined); // Маша <без отчества> Петрова
generateName('Маша', 'Петрова', null); // Маша null Петрова
generateName('Маша', 'Петрова', ''); // Маша  Петрова
generateName('Мария', 'Петрова', 'Ивановна'); // Мария Ивановна Петрова
```

---

# Функции с неопределённым числом аргументов

В **ES6** появился новый оператор: ``...`` (три точки). В зависимости от контекста применения и ожидаемой функциональности эти три точки ``...`` называют либо ``spread``, либо ``rest``.  В разных ситуациях он ведёт себя по-разному.

## При вызове функции — разбивает массив

Оператором ``spread`` можно «разложить» массив в отдельные аргументы функции. Например, метод ``Math.max`` принимает на вход сколько угодно чисел и возвращает наибольшее из них. Оператор ``spread`` позволяет передать такой функции массив, сделав из него отдельные аргументы:

```js
const nums = [4, 8, 15, 16, 23, 42];

/* Оператор spread разложит массив на отдельные
аргументы: 4, 8, 15 и так далее */

Math.max(...nums); // 42
```

## При объявлении функции — собирает аргументы в массив

Второе назначение оператора ``...`` — ``rest``-параметры. Они выполняют действие, обратное оператору ``spread``: собирают отдельные параметры функции в массив:

```js
function consoleDogs(firstDog, ...otherDogs) {
  console.log(`Первый: ${firstDog}`);
  console.log(`Остальные: ${otherDogs}`);
}

consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис');

/* В консоль будет выведено:

  Первый: Спаниель
  Остальные: ['Овчарка', 'Борзая', 'Метис']
*/
```

``rest``-параметр всегда стоит в конце.
