# Объединение и преобразование в строку

## Добавление элементов. Метод ``concat``

Метод ``concat`` применяется к массиву и создаёт из него новый. Все аргументы, переданные методу, будут добавлены в новый массив в том же порядке:

```js
const toDoList = ['Посадить дерево', 'Построить дом'];
const toDoListUpdated = toDoList.concat('Вырастить сына');

console.log(toDoListUpdated);

// ["Посадить дерево", "Построить дом", "Вырастить сына"]
```

Как аргумент можно передать и другой массив — его элементы будут скопированы и добавлены в новый массив:

```js
const moscowAttractions = ['Кремль', 'Третьяковская галерея'];
const spbAttractions = ['Эрмитаж', 'Мариинский театр'];
const volgogradAttractions = ['Мамаев Курган', 'Родина-мать'];

const russiaAttractions = moscowAttractions.concat(spbAttractions, volgogradAttractions);

// получим новый массив со значениями всех исходных массивов

console.log(russiaAttractions);

/*
  [
    "Кремль",
    "Третьяковская галерея",
    "Эрмитаж",
    "Мариинский театр",
    "Мамаев Курган",
    "Родина-мать"
  ]
*/
```

Метод ``concat`` не меняет структуру начального массива, а возвращает новый. Изменения в новом массиве не приведут к изменению исходного. Это делает код более предсказуемым.

## Преобразование массива в строку. Метод ``join``

Метод ``join`` создаёт строку из элементов массива, разделённых запятой. Их порядок не меняется:

```js
const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];

console.log(bremenMusicians.join());

// "Кот,Пёс,Трубадур,Осёл,Петух"

console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`);
// "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"

// при этом с исходным массивом ничего не произошло:
console.log(bremenMusicians);
// ["Кот", "Пёс", "Трубадур", "Осёл", "Петух"]
```

Если не передать ``join`` аргумент, элементы в строке будут перечислены через запятую. Но мы можем задать любой нужный разделитель:

```js
const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];

console.log(bremenMusicians.join(' | '));

// "Кот | Пёс | Трубадур | Осёл | Петух"
```

---

# Добавление и удаление последнего элемента

## Добавление элемента: метод ``push``

Метод ``push`` добавляет переданные ему аргументы в конец массива:

```js
const emeraldCityHeroes = ['Лев', 'Дровосек', 'Страшила'];
emeraldCityHeroes.push('Элли', 'Тотошка');

console.log(emeraldCityHeroes);

// ["Лев", "Дровосек", "Страшила", "Элли", "Тотошка"]
```

## Удаление элемента: метод ``pop``

Метод ``pop`` удаляет последний элемент массива. Он не принимает аргументы — только возвращает значение удалённого элемента. Если массив пуст, ``pop`` вернёт ``undefined``:

```js
const insects = ['Бабочка', 'Мотылёк', 'Божья коровка', 'Комар'];

console.log(insects.pop()); // "Комар"
console.log(insects); // ["Бабочка", "Мотылёк", "Божья коровка"]
```

---

# Добавление и удаление первого элемента

## Удаление первого элемента: метод ``shift``

Метод ``shift`` удаляет первый элемент массива. Исходный массив при этом **изменится**:

```js
const italyCities = ['Помпеи', 'Рим', 'Неаполь'];

const volcanoEruption = italyCities.shift();

// метод shift() возвращает удалённый элемент
console.log(volcanoEruption); // "Помпеи"

// массив остался без первого элемента
console.log(italyCities); // ["Рим", "Неаполь"]
```

Если массив изначально пустой, вернётся ``undefined``:

```js
const emptyArr = [];

console.log(emptyArr.shift()); // undefined
```

## Добавление элемента в начало массива: метод ``unshift``

Метод ``unshift`` добавляет элементы в начало массива. Их передают через запятую:

```js
const queue = ['Рабочие', 'Школьники', 'Студенты'];

queue.unshift('Пенсионеры', 'Инвалиды');

console.log(queue);

// ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"]
```

Метод ``unshift`` **изменит** исходный массив и **напишет**, сколько элементов в новом массиве:

```js
const queue = ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"];

console.log(queue.length); // 5
console.log(queue.unshift('Мне только спросить')); // 6
```

---

# Управление элементами на любых позициях

## Получение части массива: метод ``slice``

Метод ``slice`` копирует часть массива и делает из неё новый массив. Он принимает на вход два аргумента:

* индекс элемента, с которого нужно **начать** копирование (включительно);
* индекс элемента, на котором нужно **остановиться** (не включительно).

Исходный массив при этом не изменяется:

```js
const months = [
  'Январь',
  'Февраль',
  'Март',
  'Апрель',
  'Май',
  'Июнь',
  'Июль',
  'Август',
  'Сентябрь',
  'Октябрь',
  'Ноябрь',
  'Декабрь'
];

// начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
const spring = months.slice(2, 5);

console.log(spring); // ["Март", "Апрель", "Май"]

console.log(months); /* ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"] */

// Как видите, исходный массив остался нетронутым
```

Второй аргумент можно не указывать. Тогда скопированы будут все элементы до конца.

Можно передавать как аргумент и отрицательные числа. Тогда индекс будет считаться с конца массива:

```js
const months = [
  'Январь',
  'Февраль',
  'Март',
  'Апрель',
  'Май',
  'Июнь',
  'Июль',
  'Август',
  'Сентябрь',
  'Октябрь',
  'Ноябрь',
  'Декабрь'
];

// начиная с четвёртого элемента с конца и до первого с конца (не включительно)
const autumn = months.slice(-4, -1);
console.log(autumn); // ["Сентябрь", "Октябрь", "Ноябрь"]

// с третьего элемента с конца и до конца
const fourthQuarter = months.slice(-3);
console.log(fourthQuarter); // ["Октябрь", "Ноябрь", "Декабрь"]
```

Можно вызывать ``slice`` вообще без аргументов. Получится новый массив, состоящий из всех элементов исходного.

## Замена части элементов массива: метод ``splice``

Метод splice выполняет два действия: удаляет элементы из массива и добавляет на их место новые. Первый аргумент метода — индекс элемента, с которого надо начать удалять. Второй — сколько элементов нужно удалить.

Аргументы с третьего — элементы, которые мы хотим поставить на место удалённых. Их может быть сколько угодно или не быть вообще:

```js
const week = [
  'Понедельник',
  'Вторник',
  'Среда',
  'Четверг',
  'Пятница',
  'Суббота',
  'Воскресенье'
];

// начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье');

console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]

console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]
```

Этот код изменит исходный массив и вернёт новый из удалённых элементов. Новые значения добавлять необязательно — можно удалить существующие:

```js
const planets = [
  'Меркурий',
  'Венера',
  'Земля',
  'Марс',
  'Юпитер',
  'Сатурн',
  'Уран',
  'Нептун'
];

planets.splice(2, 1); // ["Земля"]
console.log(planets); // ["Меркурий", "Венера", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун"]
```

И наоборот. Можно ничего не удалять — только добавить новые элементы:

```js
const planets = [
  'Меркурий',
  'Венера',
  'Марс',
  'Юпитер',
  'Сатурн',
  'Уран',
  'Нептун'
];

planets.splice(2, 0, "Земля"); // []
console.log(planets); // ["Меркурий", "Венера", "Земля", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун"]
```

Метод ``splice`` нужен редко: большинство задач решают простыми методами. Но раз в год и палка стреляет, так что помните о ``splice``: однажды он может выручить.

---

# Очень похожи на массивы, но не массивы. Коллекции в **DOM**

``NodeList`` — коллекция, которая очень похожа на массив. Такую коллекцию можно получить с помощью метода ``querySelectorAll``. В ``NodeList`` элементы упорядочены, можно обратиться к свойству ``length`` и воспользоваться методом ``forEach``.

Есть быстрый способ превратить любой псевдомассив в массив. Для этого в **ES2015** появился метод ``Array.from``. Он создаёт массив из «массивоподобного» объекта:

```js
const posts = content.querySelectorAll('.post');

const postsArray = Array.from(posts); // такой вызов вернёт полноценный массив
```

Объект считается массивоподобным, если:

* его элементы имеют числовые индексы,
* у него есть свойство ``length``.

Метод ``querySelectorAll`` вернёт коллекцию, которая под эти критерии подходит. 

---

# Перебор массива. Методы ``forEach`` и ``map``

## Обход массива: метод ``forEach``

Метод ``forEach`` нужен для обхода массива. В качестве аргумента ``forEach`` принимает функцию. Она будет вызвана на каждом элементе массива поочерёдно:

```js
const how = ['быстрее', 'выше', 'сильнее'];

how.forEach(function (item) {
    console.log(item + '.');
});

/*
  быстрее.
  выше.
  сильнее.
*/
```

Методу ``forEach`` мы передали функцию. ``forEach`` вызовет её столько раз, сколько элементов в массиве ``how``. При каждом вызове ``forEach`` передаёт функции текущий элемент массива в качестве аргумента. Поэтому в передаваемой нами функции ``item`` — это текущий элемент массива. Параметр ``item`` можно назвать и по-другому. Но лучше сделать так, чтобы название отражало содержание.

Метод  ``forEach`` удобно использовать для работы с массивоподобными объектами. Например, с ``NodeList``. Частая задача — пройтись по нескольким **DOM** элементам, вызвав для каждого из них функцию:

```js
const elements = document.querySelectorAll('.text');

elements.forEach((item) => {
   item.classList.add('text_is-active');
});
```

Метод ``forEach`` — более удобная для работы с массивом версия цикла ``for``. Но с ``forEach`` нельзя использовать директивы ``continue`` и ``break``. Поэтому метод не используют, когда нужно прервать выполнение цикла каким-то условием.

## Создание одного массива из другого: метод ``map``

Метод ``map`` создаёт новый массив на основе существующего. В качестве аргумента ``map``, как и ``forEach``, принимает функцию. Эта функция должна вернуть значение, которое станет элементом нового массива.

```js
const firstArr = [0, 1, 2, 3, 4];

const secondArr = firstArr.map(function (item) { // Берём каждый элемент массива
  return item * item; // Возводим каждый элемент в квадрат
}); 

console.log(secondArr); // [0, 1, 4, 9, 16]
```

Результат работы функции — то, что указано после ключевого слова ``return``. Если не прописать ``return``, функция сработает, но вернёт ``undefined``:

```js
const firstArr = [0, 1, 2, 3, 4];

const secondArr = firstArr.map(function (elem) {
    console.log('Это сообщение будет выведено пять раз');
});

console.log(secondArr); // [undefined, undefined, undefined, undefined, undefined].
```

Метод ``map`` нельзя применить к массивоподобным объектам. Если попытаться вызвать код с ``NodeList`` из примера с ``forEach`` — вылезет ошибка:

```js
const elements = document.querySelectorAll('.text');

elements.map((item) => {
   item.classList.add('text_is-active');
});
// TypeError: elements.map is not a function
// потому что у elements нет метода map
```

Вы уже знаете, как избежать этой ошибки — превратить массивоподобный объект в полноценный массив c использованием ``Array.from``. Метод ``map`` удобно использовать в тех случаях, когда нужно сохранить исходный массив:

```js
const elements = document.querySelectorAll('.text');
const elementsArr = Array.from(elements);

const newArr = elementsArr.map((item) => {
    item.classList.add('text_is-active');
});
```

## Отличия между ``forEach`` и ``map``

У методов схожая логика: они перебирают массив и выполняют для каждого элемента свой код.

Метод ``forEach`` нужен, когда мы хотим просто пройтись по массиву и для каждого элемента что-то сделать.

Например, вывести твиты в консоль:

```js
const tweets = [
  'Какой-то странный тред',
  'Твит, адресованный Илону Маску',
  'Ответ на инфоповод'
];

tweets.forEach(function (tweet) {
    console.log(tweet);
});

/*
  "Какой-то странный тред"
  "Твит, адресованный Илону Маску"
  "Ответ на инфоповод"
*/
```

Метод ``map`` нужен, когда мы хотим создать новый массив из старого и преобразовать его элементы.

Всё те же твиты:

```js
const tweets = [
    {
    user: '@elonmusk',
    date: '16 марта 2019 года',
    text: "I'm from South Africa."
  },
    {
    user: '@realDonaldTrump',
     date: '24 марта 2019 года',
    text: 'Good Morning, Have A Great Day!'
  },
    {
    user: '@BillGates',
    date: '24 марта 2019 года',
    text: 'I never ate apple in my life'
  }
];

const tweetsTextOnly = tweets.map(function (el) {
    return el.text;
});

tweetsTextOnly.forEach(function (el) {
    console.log(el);
});

/*
  I'm from South Africa.
  Good Morning, Have A Great Day!
  I never ate apple in my life
*/
```

---

# Функции обратного вызова и их аргументы

Мы можем передать функцию как аргумент другой функции, чтобы та её вызывала. Вы уже проделывали это с методом ``addEventListener``:

```js
const element = document.getElementById('my-element');

// второй аргумент метода — колбэк
element.addEventListener('click', function () {
  console.log('Мы кликнули по элементу');
});
```

Метод ``addEventListener`` получил вторым аргументом функцию. Если функцию передают как аргумент, её называют «колбэком».

Методы ``forEach`` и ``map`` работают по схожему принципу: перебирают все элементы массива и для каждого вызывают колбэк.

Колбэк, который мы передаём методам ``forEach`` и ``map``, при каждом исполнении получает три аргумента. Разберём, что это за аргументы и зачем они нужны.

## Аргумент 1. Текущий элемент массива

Текущий элемент массива используется часто, поэтому и стоит на первом месте. Если другие аргументы не нужны, достаточно прописать его:

```js
const positions = [
  'Великий Умывальник',
  'Знаменитый Мойдодыр',
  'Умывальников Начальник',
  'Мочалок Командир'
];

/* Переданный колбэк будет вызван 4 раза.
По очереди с каждым элементом массива positions */

positions.forEach(function(item) {
  console.log(item);
});

/*
  Великий Умывальник
  Знаменитый Мойдодыр
  Умывальников Начальник
  Мочалок Командир
*/
```

## Аргумент 2. Индекс текущего элемента

Когда мы говорили о цикле ``for``, там был счётчик цикла. Второй аргумент колбэка — фактически такой счётчик. Его можно использовать, например, для расстановки позиций в списке:

```js
const counter = [
  'Царь',
  'Царевич',
  'Король',
  'Королевич',
  'Сапожник',
  'Портной'
];

const counterIndexed = counter.map(function (person, index) {
    return `${index + 1}. ${person}`;
});

console.log(counterIndexed);

/*
[
  "1. Царь",
  "2. Царевич",
  "3. Король",
  "4. Королевич",
  "5. Сапожник",
  "6. Портной"
]
*/
```

Обратите внимание: неважно, какое имя параметра выбрано в объявлении функции — ``person``, ``item`` или любое другое. Первый параметр считывается как текущий элемент, второй — как его индекс.

## Аргумент 3. Исходный массив

Исходный массив как аргумент пригодится, когда нужно обратиться к свойствам этого исходного массива:

```js
const ivans = [
  'Иван I Калита',
  'Иван II  Красный',
  'Иван III Великий',
  'Иван IV Грозный',
  'Иван V',
  'Иван VI'
];

const ivansIndexed = ivans.map(function(item, index, array) {
  const currentIndex = `(${(index + 1)} из ${array.length})`;
  return `${item} ${currentIndex}`;
});

console.log(ivansIndexed);

/*
[
  "Иван I Калита (1 из 6)",
  "Иван II  Красный (2 из 6)",
  "Иван III Великий (3 из 6)",
  "Иван IV Грозный (4 из 6)",
  "Иван V (5 из 6)",
  "Иван VI (6 из 6)"
]
*/
```

---

# Отбор элементов массива: метод ``filter``

Метод ``filter`` отсеивает элементы массива по заданному признаку. Как ``forEach`` и ``map``, метод ``filter`` принимает колбэк в качестве аргумента. Этот колбэк будет вызван на каждом элементе. Он должен вернуть ``true`` или ``false`` в зависимости от того, хотим мы оставить текущий элемент массива или отфильтровать:

```js
const a = [1, 9, 2, 2, 3, 4, 1, 7, 8, 0, 9, 0, 1, 5, 3];

// отберём элементы больше 5
const b = a.filter(function (item) {
  return item > 5
});

console.log(b); // [9, 7, 8, 9]
```

Метод ``filter`` создаёт новый массив из элементов, для которых функция-фильтр вернула ``true``. При этом исходный массив не меняется.

Колбэк метода ``filter`` — те же три параметра, что и у ``map`` и ``forEach``. Текущий элемент, его индекс и исходный массив:

```js
const a = [1, 9, 2, 2, 3, 4, 1, 7, 8, 0, 9, 0, 1, 5, 3];

const b = a.filter(function (item, position, array) {
  return array.lastIndexOf(item) === position; // вернём уникальные элементы
});

console.log(a); // [1, 9, 2, 2, 3, 4, 1, 7, 8, 0, 9, 0, 1, 5, 3]
console.log(b); // [2, 4, 7, 8, 9, 0, 1, 5, 3]
```

Так же как и методы map и ``forEach``, метод ``filter`` можно использовать для работы с данными, которые потом отрисовываются в **DOM**. Вернёмся к твитам — вы можете найти твиты по определённым параметрам и, применяя метод ``forEach``, добавить их в **DOM**:

```js
const tweets = [
    {
        user: '@elonmusk',
        date: '16 марта 2019 года',
        text: "I'm from South Africa."
    },
    {
        user: '@realDonaldTrump',
        date: '24 марта 2019 года',
        text: 'Good Morning, Have A Great Day!'
    },
    {
        user: '@BillGates',
        date: '24 марта 2019 года',
        text: 'I never ate apple in my life'
    }
];

const filteredTweets = tweets.filter(function (item) => {
    return item.text.length > 25;
});

filteredTweets.forEach((item) => {
    document.body.append(addTweet(item));
});
```

---

# Методы ``some``, ``every``, ``find``

## Проверка элементов массива. Метод ``some``

Метод ``some`` проверяет, есть ли в массиве хотя бы один элемент, который соответствует определённому правилу. Колбэк с этим правилом проверяет каждый элемент и возвращает ``true`` или ``false``:

```js
const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];

const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
});

console.log(nemo); // true
```

Колбэк принимает на вход всё те же аргументы:

* текущий элемент массива,
* его индекс,
* сам исходный массив.

Метод ``some`` начинает проверку с первого элемента и продолжает, пока не встретит первое значение, для которого колбэк вернёт ``true``. Если оно найдено, метод прекратит проверку и тоже вернёт ``true``. Если нет — вернёт ``false``.

## Поиск элемента в массиве. Метод ``find``

Метод ``find`` очень похож на ``some``. Единственное отличие: ``some`` возвращает булево значение, а ``find`` — значение элемента, на котором он завершил проверку:

```js
const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
];

const includesCrow = birds.some(function (bird) {
    return bird.includes('ворона');
});

const crow = birds.find(function (bird) {
    return bird.includes('ворона');
});

console.log(includesCrow); // true
console.log(crow); // "Чёрно-белая ворона"
```

## Проверка элементов массива. Метод ``every``

Метод ``every`` тоже похож на ``some``, но проверяет все элементы массива и возвращает ``true``, только если все элементы прошли проверку.

**Колбэк** — единственный аргумент метода. Он содержит логику проверки каждого элемента и возвращает ``true`` или ``false``:

```js
const jokes = [
  'смешная шутка и доля правды',
  'не очень смешной анекдот + доля правды',
  'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
];

const allJokesWithTruth = jokes.every(function (joke) {
  return joke.indexOf('доля правды') > -1;
});

console.log(allJokesWithTruth); // true
```

Если по мере перебора элементов колбэк возвращает ``false``, метод every завершает проверку и тоже возвращает ``false``.

---

# Сведение массива. Метод ``reduce``

Метод ``reduce`` перебирает элементы массива и сводит его к одному значению.

Проще всего показать это на примере сложения. Есть массив чисел, нужно посчитать сумму всех его элементов.

Так задачу решают циклом ``for``:

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let sum = 0; // создадим переменную, где будем хранить сумму

// проходим по всем элементам массива 
// прибавляем каждый из них к переменной-аккумулятору sum 

for (let i = 0; i < arr.length; i += 1) {
  sum += arr[i];
}

console.log(sum);
```

А можно её решить методом ``reduce``.

Он работает как ``forEach``: перебирает элементы массива и выполняет для каждого свой код. У колбэка ``reduce`` те же аргументы, но добавляется один новый. Он ставится на первое место, а «старые» идут за ним: текущий элемент, индекс и исходный массив.

## Новый аргумент. Промежуточное значение

Промежуточное значение — новый первый аргумент и главная особенность ``reduce``. На каждой итерации этот аргумент равен тому, что в прошлый раз вернул колбэк.

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sum = arr.reduce(function (previousValue, item) {
  return previousValue + item;
});

console.log(sum);
```

Запись ``return previousValue + item`` означает: «прибавь текущий элемент массива к тому, что получилось на предыдущей итерации».
Выведем в консоль все промежуточные значения:

```js
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const sum = arr.reduce(function (previousValue, item) {
  // для наглядности выведем аргументы в консоль
  console.log(`previousValue: ${previousValue}, item: ${item}`);
  return previousValue + item;
});

console.log(`sum: ${sum}`);

/*
 previousValue: 1, item: 2
 previousValue: 3, item: 3
 previousValue: 6, item: 4
 previousValue: 10, item: 5
 previousValue: 15, item: 6
 previousValue: 21, item: 7
 previousValue: 28, item: 8
 previousValue: 36, item: 9
 sum: 45
*/
```

На первой итерации значение ``previousValue`` — первый элемент массива, ``item`` — второй. На второй итерации ``previousValue`` — сумма первых двух элементов, ``item`` — третий элемент. После последнего ``item`` в ``sum`` будет итоговая сумма всех элементов массива.

## Начальное значение

На первой итерации промежуточное значение — первый элемент массива. Но это значение можно задать самостоятельно. Тогда действия с массивом начнутся с него.

Первый аргумент метода ``reduce`` — колбэк. А вот вторым нужно задать промежуточное значение ``previousValue`` при первой итерации.

Передадим ``reduce`` первым аргументом колбэк, а вторым **1000**:

```js
/* Создадим массив, хранящий в себе историю выигрышей
и проигрышей одного игрока в казино. */
const winsAndLoses = [190, 117, -381, -394, -36, 137, -473, 372, -383];

/* Посчитаем, какая сумма денег останется у этого игрока
к концу вечера, если вначале у него было с собой 1000. */
const total = winsAndLoses.reduce(function (previousValue, item) {
    return previousValue + item;
}, 1000); // Начальное значение передаём методу reduce как второй аргумент.

console.log(total); // 149. Чего ещё ожидать от азартных игр?
```

Есть популярная задача: дан массив, чьи элементы могут повторяться. Нужно создать объект, в котором ключи — это элементы массива, а значения — число повторений соответствующих элементов. Если в исходном массиве есть 3 элемента со значением «яблоко», в конечном объекте должно быть свойство «яблоко» со значением 3.
Тогда методу ``reduce`` вторым аргументом передают пустой объект:

```js
const order = ['яблоко', 'банан', 'апельсин', 'банан', 'яблоко', 'банан'];

const result = order.reduce(function (prevVal, item) {
  if (!prevVal[item]) {
    // если ключа ещё нет в объекте, значит это первое повторение
    prevVal[item] = 1;
  } else {
    // иначе увеличим количество повторений на 1
    prevVal[item] += 1;
  }

  // и вернём изменённый объект
  return prevVal;
}, {}); // Начальное значение — пустой объект.

console.log(result); // { яблоко: 2, банан: 3, апельсин: 1 }
```

## Суть метода ``reduce``

Как работает метод ``reduce``:

* сводит массив к одному значению: числу, массиву, объекту;
* принимает на вход 2 аргумента: обязательный колбэк и исходное значение его первого аргумента;
* содержит в колбэке 4 аргумента: промежуточное значение, текущий элемент, его индекс и сам исходный массив.

---

# Сортировка массива

## Сортировка без функции обратного вызова

Метод ``sort`` принимает на вход колбэк. Но для других методов колбэк обязателен, а для ``sort`` нет:

```js
const myNumbers = [0, 3.14, 2.718, 13];
myNumbers.sort();
myNumbers; // [0, 13, 2.718, 3.14]
```

Элементы поменялись местами, но их порядок не поддаётся логике: они не выстроены ни по возрастанию, ни по убыванию.

Но логика тут всё-таки есть. Метод ``sort`` работал с элементами массива как со строками. Будь это слова, они бы выстроились по алфавиту:

```js
const fruits = ['яблоко', 'банан', 'апельсин', 'томат'];
fruits.sort(); // ["апельсин", "банан", "томат", "яблоко"] 
```

## Функции обратного вызова для сортировки

На практике метод ``sort`` редко вызывают без аргументов. По двум причинам:

* нам не всегда нужна сортировка по возрастанию,
* нам точно не нужно сортировать числа как строки.

Поэтому ``sort`` принимает на вход колбэк, в котором описана логика сортировки элементов.

Любой алгоритм сортировки — последовательное сравнение двух элементов. Один из них будет стоять в итоговом массиве раньше, другой — позже. Логику, по которой элементы будут сравниваться, описывают внутри колбэка метода ``sort``.

Колбэк принимает на вход два аргумента — два элемента массива, которые предстоит сравнивать. Способ сравнения нужно описать в колбэке. Метод ``sort`` расставляет элементы исходя из значения, которое возвращает колбэк.

Есть ограничение: колбэк обязан возвращать число. Оно может быть:

1. Меньше нуля — первый элемент, переданный как аргумент колбэка, встанет в массиве раньше второго.
2. Больше нуля — наоборот, второй элемент окажется раньше первого.
3. Равно нулю — порядок не изменится, элементы будут стоять как в исходном массиве.

Вернёмся к массиву с числами и отсортируем его по возрастанию:

```js
const myNumbers = [0, 3.14, 2.718, 13];

myNumbers.sort(function (a, b) {
    return a - b;

  /* Если a меньше b, вернётся отрицательное число.
  Это значит, что a должно расположиться в итоговом массиве
  раньше, b — позже. Например:

    a = 0, b = 3.14
    a - b = -3.14

  Получили отрицательное число, значит a стоит раньше b */
});

console.log(myNumbers); // [0, 2.718, 3.14, 13] — так и есть
```

Если же элементы массива — строки, трюк не пройдёт: вычитание одной строки из другой вернёт ``NaN``. Придётся указывать, какая строка считается «большей», а какая — «меньшей», и прописывать для разных случаев возвращаемое значение:

```js
/* Диагнозы записаны в том порядке,
в каком поступили пациенты. Отсортируем его по алфавиту. */

const diagnoses = [
  'мизофобия',
  'синдром упущенной выгоды',
  'боязнь красного цвета'
];

diagnoses.sort(function(a, b) {
  /* приведём строки к нижнему регистру,
  чтобы сравнение прошло корректно */
  a = a.toLowerCase();
  b = b.toLowerCase();

    if (a < b) return -1; // a расположится раньше b
    if (b < a) return 1; // b расположится раньше a

  return 0;
});

console.log(diagnoses);

/* ["боязнь красного цвета", "мизофобия", "синдром упущенной выгоды"] */
```
